/*
Copyright ArxanFintech Technology Ltd. 2017 All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

                 http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package utils

import (
	"crypto/aes"
	"crypto/cipher"
	"crypto/rand"
	"crypto/sha256"
	"encoding/base64"
	"encoding/hex"
	"fmt"
	"io"
	"math/big"
	mrand "math/rand"
	"os"
	"strconv"
	"strings"
	"time"

	"github.com/btcsuite/btcutil/base58"
	gp "github.com/golang/protobuf/ptypes/timestamp"
	sid "github.com/ventu-io/go-shortid"

	"regexp"

	"golang.org/x/crypto/bcrypt"
	"golang.org/x/crypto/ripemd160"
	"golang.org/x/crypto/sha3"
)

type alg struct {
	hashFun func([]byte) string
	decoder func(string) ([]byte, error)
}

var availableIDgenAlgs = map[string]alg{
	"sha256base64": alg{GenerateUUIDfromTxSHAHash, base64.StdEncoding.DecodeString},
}

var shortIDGenerator *sid.Shortid

func init() {
	shortIDGenerator, _ = sid.New(1, sid.DefaultABC, 2342)
}

// GenerateShortID generates a short id (length = 9)
func GenerateShortID() string {
	id, _ := shortIDGenerator.Generate()
	return id
}

// i=1, lenght=2 -> result=01
// i=10, lenght=2 -> result=10
// i=1, lenght=3 -> result=001
func Int2Str(i, length int) (result string) {
	result = strconv.Itoa(i)
	if len(result) < length {
		strlen := length - len(result)
		var strSlice []string
		for i := 0; i < strlen; i++ {
			strSlice = append(strSlice, "0")
		}
		strSlice = append(strSlice, result)
		result = strings.Join(strSlice, "")
	}
	return
}

func ArraytoString(data []string) string {
	result := "["
	for _, str := range data {
		result = result + "\"" + str + "\","
	}
	// delete the last ","
	result = result[:len(result)-1] + "]"
	return result
}

// CalculateBCHash returns the Bitcoin hash (double sha256) of
// the given transaction
func CalculateBCHash(txData []byte) [32]byte {
	firstHash := sha256.Sum256(txData)
	txHash := sha256.Sum256(firstHash[:])
	return txHash
}

// ComputeCryptoHash should be used in openchain code so that we can change the actual algo used for crypto-hash at one place
func ComputeCryptoHash(data []byte) (hash []byte) {
	hash = make([]byte, 64)
	sha3.ShakeSum256(hash, data)
	return
}

func ComputeSha256(data string) string {
	sha_256 := sha256.New()
	// drop those digits after the decimal
	sha_256.Write([]byte(strings.Split(data, ".")[0]))
	bt := sha_256.Sum(nil)
	return hex.EncodeToString(bt[:])
}

// ComputeBitcoinAddress compute address from public key
// Key hash = RIPEMD-160(SHA-256(public key))
// Checksum = SHA-256(SHA-256(Key hash)) first 4 bytes
// Bitcoin Address = Base58Encode(Key hash + Checksum)
func ComputeBitcoinAddress(pk []byte) string {
	sha := sha3.New256()
	sum1 := sha.Sum(pk)
	sum2 := sha.Sum(sum1)

	r160 := ripemd160.New()
	hash := r160.Sum(sum1)

	address := append(hash, sum2[:4]...)
	return EncodeBase58(address)
}

// Check if the data is valid SHA1, MD5 or SHA256 string.
func IsHexdigest(data, digestType string) (valid bool, err error) {
	valid = false
	err = nil
	if digestType == "" {
		// default is sha256
		digestType = "sha256"
	}
	switch strings.ToLower(digestType) {
	case "sha1":
		valid = _digestMatch(40, data)
	case "sha256":
		valid = _digestMatch(64, data)
	case "md5":
		valid = _digestMatch(32, data)
	default:
		err = fmt.Errorf("Unsupported type: %s", digestType)
	}
	return
}

func StringInSlice(a string, list []string) bool {
	for _, b := range list {
		if b == a {
			return true
		}
	}
	return false
}

func _digestMatch(length int, str string) (valid bool) {
	valid = false
	// disable regexp match to avoid performance issue, until we find better solution
	// pattern := fmt.Sprintf("[a-fA-F0-9]{%d}", length)
	if len(str) == length {
		//match, _ := regexp.MatchString(pattern, str); match && len(str) == length {
		valid = true
	}
	return
}

// GenerateBytesUUID returns a UUID based on RFC 4122 returning the generated bytes
func GenerateBytesUUID() []byte {
	uuid := make([]byte, 16)
	_, err := io.ReadFull(rand.Reader, uuid)
	if err != nil {
		panic(fmt.Sprintf("Error generating UUID: %s", err))
	}

	// variant bits; see section 4.1.1
	uuid[8] = uuid[8]&^0xc0 | 0x80

	// version 4 (pseudo-random); see section 4.1.3
	uuid[6] = uuid[6]&^0xf0 | 0x40

	return uuid
}

// GenerateIntUUID returns a UUID based on RFC 4122 returning a big.Int
func GenerateIntUUID() *big.Int {
	uuid := GenerateBytesUUID()
	z := big.NewInt(0)
	return z.SetBytes(uuid)
}

// GenerateUUID returns a UUID based on RFC 4122
func GenerateUUID() string {
	uuid := GenerateBytesUUID()
	return uuidBytesToStr(uuid)
}

// validate UUID base on RFC 4122(uuid v4)
func ValidateUUID(uuid string) bool {
	r := regexp.MustCompile("^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-4[a-fA-F0-9]{3}-[8|9|aA|bB][a-fA-F0-9]{3}-[a-fA-F0-9]{12}$")
	return r.MatchString(uuid)
}

// validate base64 encoding string
func ValidateBase64EncodingString(encodingString string) bool {
	r := regexp.MustCompile("^[a-zA-Z0-9+/=]+$")
	return r.MatchString(encodingString)
}

// validate txid from blockchain return
func ValidateTXID(txid string) bool {
	r := regexp.MustCompile("^[a-fA-F0-9]{64}$")
	return r.MatchString(txid)
}

// CreateUtcTimestamp returns a google/protobuf/Timestamp in UTC
func CreateUtcTimestamp() *gp.Timestamp {
	now := time.Now().UTC()
	secs := now.Unix()
	nanos := int32(now.UnixNano() - (secs * 1000000000))
	return &(gp.Timestamp{Seconds: secs, Nanos: nanos})
}

// CreateUtcToday return current utc date, format is: "%d-%02d-%02d"
func CreateUtcToday() string {
	now := time.Now().UTC()
	result := make([]byte, 10)
	sy := strconv.FormatInt(int64(now.Year()), 10)
	sM := Int2Str(int(now.Month()), 2)
	sd := Int2Str(int(now.Day()), 2)
	bl := 0
	bl += copy(result[bl:], sy)
	bl += copy(result[bl:], "-")
	bl += copy(result[bl:], sM)
	bl += copy(result[bl:], "-")
	copy(result[bl:], sd)
	return string(result)
}

//GenerateHashFromSignature returns a hash of the combined parameters
func GenerateHashFromSignature(path string, ctor string, args []string) []byte {
	fargs := ctor
	if args != nil {
		for _, str := range args {
			fargs = fargs + str
		}
	}
	cbytes := []byte(path + fargs)

	b := make([]byte, len(cbytes))
	copy(b, cbytes)
	hash := ComputeCryptoHash(b)
	return hash
}

// GenerateUUIDfromTxSHAHash generates SHA256 hash using Tx payload, and uses its first
// 128 bits as a UUID
func GenerateUUIDfromTxSHAHash(txData []byte) string {
	txHash := sha256.Sum256(txData)
	return uuidBytesToStr(txHash[0:16])
}

// GenerateIDWithAlg generates an ID using a custom algorithm
func GenerateIDWithAlg(customIDgenAlg string, encodedPayload string) (string, error) {
	var alg = availableIDgenAlgs[customIDgenAlg]
	if alg.hashFun != nil && alg.decoder != nil {
		var payload, err = alg.decoder(encodedPayload)
		if err != nil {
			return "", err
		}
		return alg.hashFun(payload), nil
	}
	return "", fmt.Errorf("Wrong UUID generation algorithm was given.")
}

func uuidBytesToStr(uuid []byte) string {
	return fmt.Sprintf("%x-%x-%x-%x-%x", uuid[0:4], uuid[4:6], uuid[6:8], uuid[8:10], uuid[10:])
}

// FindMissingElements identifies the elements of the first slice that are not present in the second
// The second slice is expected to be a subset of the first slice
func FindMissingElements(all []string, some []string) (delta []string) {
all:
	for _, v1 := range all {
		for _, v2 := range some {
			if strings.Compare(v1, v2) == 0 {
				continue all
			}
		}
		delta = append(delta, v1)
	}
	return
}

// DecodeBase64 decodes from Base64
func DecodeBase64(in string) ([]byte, error) {
	return base64.StdEncoding.DecodeString(in)
}

// EncodeBase64 encodes to Base64
func EncodeBase64(in []byte) string {
	return base64.StdEncoding.EncodeToString(in)
}

// DecodeBase58 decodes from Base58
func DecodeBase58(in string) []byte {
	return base58.Decode(in)
}

// EncodeBase58 encodes to Base58
func EncodeBase58(in []byte) string {
	return base58.Encode(in)
}

// IntArrayEquals checks if the arrays of ints are the same
func IntArrayEquals(a []int, b []int) bool {
	if len(a) != len(b) {
		return false
	}
	for i, v := range a {
		if v != b[i] {
			return false
		}
	}
	return true
}

// Encrypt string to base64 crypto using AES
func Encrypt(key []byte, text string) string {
	plaintext := []byte(text)

	block, err := aes.NewCipher(key)
	if err != nil {
		panic(err)
	}

	// The IV needs to be unique, but not secure. Therefore it's common to
	// include it at the beginning of the ciphertext.
	ciphertext := make([]byte, aes.BlockSize+len(plaintext))
	iv := ciphertext[:aes.BlockSize]
	if _, err := io.ReadFull(rand.Reader, iv); err != nil {
		panic(err)
	}

	stream := cipher.NewCFBEncrypter(block, iv)
	stream.XORKeyStream(ciphertext[aes.BlockSize:], plaintext)

	// convert to base64
	return base64.URLEncoding.EncodeToString(ciphertext)
}

// Decrypt from base64 to decrypted string
func Decrypt(key []byte, cryptoText string) string {
	ciphertext, _ := base64.URLEncoding.DecodeString(cryptoText)

	block, err := aes.NewCipher(key)
	if err != nil {
		panic(err)
	}

	// The IV needs to be unique, but not secure. Therefore it's common to
	// include it at the beginning of the ciphertext.
	if len(ciphertext) < aes.BlockSize {
		panic("ciphertext too short")
	}
	iv := ciphertext[:aes.BlockSize]
	ciphertext = ciphertext[aes.BlockSize:]

	stream := cipher.NewCFBDecrypter(block, iv)

	// XORKeyStream can work in-place if the two arguments are the same.
	stream.XORKeyStream(ciphertext, ciphertext)

	return fmt.Sprintf("%s", ciphertext)
}

// Encrypt string to base64 RawURLEncoding crypto using AES
func RawEncrypt(key []byte, text string) string {
	plaintext := []byte(text)

	block, err := aes.NewCipher(key)
	if err != nil {
		panic(err)
	}

	// The IV needs to be unique, but not secure. Therefore it's common to
	// include it at the beginning of the ciphertext.
	ciphertext := make([]byte, aes.BlockSize+len(plaintext))
	iv := ciphertext[:aes.BlockSize]
	if _, err := io.ReadFull(rand.Reader, iv); err != nil {
		panic(err)
	}

	stream := cipher.NewCFBEncrypter(block, iv)
	stream.XORKeyStream(ciphertext[aes.BlockSize:], plaintext)

	// convert to base64
	return base64.RawURLEncoding.EncodeToString(ciphertext)
}

// Decrypt from base64 RawURLEncoding to decrypted string
func RawDecrypt(key []byte, cryptoText string) string {
	ciphertext, _ := base64.RawURLEncoding.DecodeString(cryptoText)

	block, err := aes.NewCipher(key)
	if err != nil {
		panic(err)
	}

	// The IV needs to be unique, but not secure. Therefore it's common to
	// include it at the beginning of the ciphertext.
	if len(ciphertext) < aes.BlockSize {
		panic("ciphertext too short")
	}
	iv := ciphertext[:aes.BlockSize]
	ciphertext = ciphertext[aes.BlockSize:]

	stream := cipher.NewCFBDecrypter(block, iv)

	// XORKeyStream can work in-place if the two arguments are the same.
	stream.XORKeyStream(ciphertext, ciphertext)

	return fmt.Sprintf("%s", ciphertext)
}

// EncryptPassword encrypt password and return hash result
// you can not decrypt this password any more
func EncryptPassword(pass string) string {
	h, err := bcrypt.GenerateFromPassword([]byte(pass), bcrypt.DefaultCost)
	if err != nil {
		h = []byte(pass)
	}
	return string(h)
}

// VerifyPassword verify the pass is match with the given hash
func VerifyPassword(pass, hash string) bool {
	err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(pass))
	return err == nil
}

// generate random string
var (
	codes   = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/~!@#$%^&*()_="
	codeLen = len(codes)
)

func RandNewStr(len int) string {
	data := make([]byte, len)
	mrand.Seed(time.Now().UnixNano())

	for i := 0; i < len; i++ {
		idx := mrand.Intn(codeLen)
		data[i] = byte(codes[idx])
	}
	return string(data)
}

// CopyFile copies a file from src to dst. If src and dst files exist, and are
// the same, then return success. Otherise, attempt to create a hard link
// between the two files. If that fail, copy the file contents from src to dst.
func CopyFile(src, dst string) (err error) {
	sfi, err := os.Stat(src)
	if err != nil {
		return
	}
	if !sfi.Mode().IsRegular() {
		// cannot copy non-regular files (e.g., directories,
		// symlinks, devices, etc.)
		return fmt.Errorf("CopyFile: non-regular source file %s (%q)", sfi.Name(), sfi.Mode().String())
	}
	dfi, err := os.Stat(dst)
	if err != nil {
		if !os.IsNotExist(err) {
			return
		}
	} else {
		if !(dfi.Mode().IsRegular()) {
			return fmt.Errorf("CopyFile: non-regular destination file %s (%q)", dfi.Name(), dfi.Mode().String())
		}
		if os.SameFile(sfi, dfi) {
			return
		}
	}
	if err = os.Link(src, dst); err == nil {
		return
	}
	err = copyFileContents(src, dst)
	return
}

// copyFileContents copies the contents of the file named src to the file named
// by dst. The file will be created if it does not already exist. If the
// destination file exists, all it's contents will be replaced by the contents
// of the source file.
func copyFileContents(src, dst string) (err error) {
	in, err := os.Open(src)
	if err != nil {
		return
	}
	defer in.Close()
	out, err := os.Create(dst)
	if err != nil {
		return
	}
	defer func() {
		cerr := out.Close()
		if err == nil {
			err = cerr
		}
	}()
	if _, err = io.Copy(out, in); err != nil {
		return
	}
	err = out.Sync()
	return
}
